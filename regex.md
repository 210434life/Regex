##### 简介

正则表达式(Regular expression，简称regex)，本质上是一个微小的并且高度专业化的编程语言。它被嵌入到Python中，并通过re模块提供给程序员使用。

正则表达式模式被编译成一系列的字节码，然后由一个C语言的匹配引擎执行。所以正则表达式效率极高。

##### re模块的操作

在python中需要通过正则表达式对字符串进行匹配的时候,需要使用一个模块,名为re

```python
#coding:utf-8

#导入模块
import re

#使用match方法进行匹配操作
res = re.match(正则表达式, 要匹配的字符)
"""
如果字符串符合正则表达式，match就会返回一个对象
如果不符合，就无返回
"""

#如果上一步匹配到数据的话，就可以使用group方法来提取数据
res.group()
```

##### 字符匹配

大多数字母和数字会匹配它们自身，有少数特殊的字符不能匹配自身，被称为元字符（metacharacter），元字符有：

```python
. ^ $ * ? {} [] | \ ()
```

##### 反斜杠

正则表达式提供"\\"来使得一些普通的字符拥有特殊能力(比如\d)，或者剥夺特殊字符的能力(比如\\[匹配左方括号"[")。由于正则表达式不是Python的核心部分，因此没有为它提供特殊的语法支持，正则表达式只能以字符串的形式表示。所以这会跟Python字符串实现相同功能的字符发生冲突。**所以建议使用Python的原始字符串表示正则表达式, r"正则表达式"。**

| 字符 | 功能                   |
| ---- | ---------------------- |
| \    | 转义字符，\\.   \\^ 等 |

##### 编译正则表达式

正则表达式被编译为模式对象，该对象拥有各种方法操作字符串

```python
import re
regex = re.complie("这种表达方式")
#regex是一个模式对象， 拥有很多方法

#模式对象的方法
ret = regex.match() 
"""
判断一个正则表达式是否从开始处匹配一个字符串
找到，返回一个匹配对象(match object)，否则返回None
"""
ret = regex.search()
"""
遍历字符串，找到正则表达式匹配的第一个位置
找到，返回一个匹配对象(match object)，否则返回None
"""
regex.findall()
""""
遍历字符串，找到正则表达式匹配的所有位置，并以列表的形式返回
"""
regex.finditer()
"""
遍历字符串，找到正则表达式匹配的所有位置，并以迭代器的形式返回
"""
#findall需要创建一个列表，finditer()返回一个迭代器

#匹配对象的方法
ret.group()
"""
返回匹配的字符串
"""
ret.start()
"""
返回匹配的开始位置
match是从开始匹配的，所以start()返回总是0
"""
ret.end()
"""
返回匹配的结束位置
"""
ret.span()
"""
返回一个元组元素表示匹配的位置(start, end)
"""
```

编译标志可以修改正则表达式的工作方式，例如：re.S即re.DOTALL 使得.匹配任何符号，包括换行符

##### 高级级别的函数

re模块提供了一些全局函数，不一定需要先创建对象，然后调用它的匹配方法。

这些函数的第一个参数是正则表达式，其他参数跟模式对像同名的方法一样，返回值也是一样。

```python
import re

re.match(regx, str)
"""
从头开始匹配
"""

re.search(r"\d+", "阅读数：9999， 点赞数：100")
"""
search()方法用于在字符串中搜索正则表达式第一次出现的位置
结果只会返回到第一个是匹配的结果
"""

re.findall(r"\d+", "阅读数：9999，点赞数：100")
#返回一个列表，所有匹配的字符串

re.sub(正则, 字符串1, 需要匹配的字符串2)
#在字符串2中匹配出来的结果用字符串1替换
#没有找到就返回原字符串
re.sub(正则, 函数, 需要匹配的字符串)
#在字符串里匹配的结果传入函数中

re.split()
"""
在正则表达式匹配的地方进行分割，并返回一个列表
"""
```

这些函数只是自动创建一个模式对象，并调用相关的函数，它们将编译好的模式对象存放在缓存中，直接使用。

如果只是偶尔使用到正则表达式，那么函数是比较方便的。如果程序需要大量使用正则表达式，例如循环，建议使用编译后的模式对象，因为预编译的话，可以节省一些函数的调用。

##### 匹配单个字符

| 字符 | 功能                                                         |
| ---- | ------------------------------------------------------------ |
| .    | 匹配任意1个字符(除\n)，re.match(正则, 字符串, re.S)可以匹配\n |
| []   | 匹配[]中列举的字符，字符类                                   |
| \d   | 匹配数字，即0~9                                              |
| \D   | 匹配非数字，即不是数字                                       |
| \s   | 匹配空白，包括空格、Tab键、换行                              |
| \S   | 匹配非空格                                                   |
| \w   | 匹配单词字符，即a-z、A-Z、0-9、_、其他语言也行               |
| \W   | 匹配非单词字符                                               |
| \b   | 匹配单词的开始与结束，匹配单词的开始与结束的零宽断言，“单词”的结束是指空格或者会字母数字的字符(除了_)，在Python中，\b表示退格符 |
| \B   | 与\b相反，表示单词的非单词边界                               |

##### 匹配多个字符

| 字符  | 功能                                                         |
| ----- | ------------------------------------------------------------ |
| *     | 匹配前一个字符出现0次或者无限次，即可有可无                  |
| +     | 匹配前一个字符出现1次或者无限次，即至少有1次                 |
| ？    | 匹配前一个字符出现1次或者0次，即要么有1次，要么没有，最多一次 |
| {m}   | 匹配前一个字符出现m次                                        |
| {m,n} | 匹配前一个字符出现从m到n次                                   |

##### 开头结尾

| 字符    | 功能 |
| ------- | ---- |
| ^或者\A | 开头 |
| $或者\Z | 结尾 |

##### 

```python
import re

def fun1(name_list):
    for name in name_list:
        ret = re.match(r"^[a-zA-Z_][a-zA-Z_0-9]*$", name)
        if ret:
            print("变量:%s 符合规则, 匹配结果:%s" % (name, ret.group()))
        else:
            print("变量:%s 不符合规则" % name)
            
def fun2():
    while True:
        mail_input = input("请输入邮箱地址: ")
        if mail_input.upper() == "Q":
            bresk
        mail_addr = re.match(r"^[a-zA-Z0-9_]@(163|qq)\.com$", mail_input)
        if mail_addr:
            print("%s 正确, 匹配结果: %s" %(mail_input, mail_addr.group()))
        else:
            print("%s 错误" % mail_input)
                
if __name__ == "__main__":
    name_list = {"__name__", "_name_", "name", "name123", "212name", "*sjfj", "sad*", "____"}
    fun1(name_list)
    fun2()
```

##### 分组

| 字符              | 功能                                                         |
| ----------------- | ------------------------------------------------------------ |
| \|                | 匹配左右任意一个表达式，即A\|B匹配A或者B，一般需要括号       |
| (ab)              | 将括号中的字符作为一个分组，group()方法可以一次性获得多个子组的序号 |
| \num              | 引用分组num匹配到字符串，反向引用即在后面的位置使用前面先前匹配过的内容 |
| (?P<name> 字符串) | 分组起别名                                                   |
| (?P=name)         | 引用别名为name分组匹配到的字符串                             |
| (?:regex)         | 非捕获组，group()返回的是整个结果，不会是很多子组            |
| [^abc]            | 匹配除了abc的                                                |

```python
()括号分组匹配到的，在match方法返回的对象中，可以使用group(n)来获取匹配到第n个分组的字符串
```

```python
import re

def fun(lst):
	for url in lst:
		ret = re.match(r"<(?P<p1>\w*)><(?P<p2>\w*)>.*</(?P=p2)></(?P=p1)>", url)
		if ret:
			print("%s 匹配成功,匹配结果: %s" % (url, ret.group()))
		else:
			print("%s 错误" % url)

if __name__ == "__main__":
	url = [
		"<h1>abc</h1>",
		"<h1>bcd<h2>",
		"<h1><font>123</font></h1>",
		"<h1>11</font>",
		"123"
	]
	fun(url)
```

##### 贪婪与非贪婪

当重复一个正则表达式时，如果使用a*，那么结果是尽可能多地去匹配。贪婪模式地限定符?

```python
import re

re.match("<.*?>", str)
#限定查找到第一个即可返回
```
